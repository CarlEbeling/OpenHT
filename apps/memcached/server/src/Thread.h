/* Copyright (c) 2015 Convey Computer Corporation
 *
 * This file is part of the OpenHT memcached application.
 *
 * Use and distribution licensed under the BSD 3-clause license.
 * See the LICENSE file for the complete license text.
 */
#pragma once

class CConn;
/*
 * Number of worker threads that have finished setting themselves up.
 */
extern int init_count;
extern pthread_mutex_t init_lock;
extern pthread_cond_t init_cond;

/* thread-specific variable for deeply finding the item lock type */
extern pthread_key_t item_lock_type_key;

/** Stats stored per slab (and per thread). */
struct CSlabStats {
    uint64_t  m_setCmds;
    uint64_t  m_getHits;
    uint64_t  m_touchHits;
    uint64_t  m_deleteHits;
    uint64_t  m_casHits;
    uint64_t  m_casBadVal;
    uint64_t  m_incrHits;
    uint64_t  m_decrHits;
};

/**
 * Stats stored per-thread.
 */
struct CThreadStats {
    //pthread_mutex_t   mutex;
    uint64_t          m_getCmds;
    uint64_t          m_getMisses;
    uint64_t          m_touchCmds;
    uint64_t          m_touchMisses;
    uint64_t          m_deleteMisses;
    uint64_t          m_incrMisses;
    uint64_t          m_decrMisses;
    uint64_t          m_casMisses;
    uint64_t          m_bytesRead;
    uint64_t          m_bytesWritten;
    uint64_t          m_flushCmds;
    uint64_t          m_connYields; /* # of yields for connections (-R option)*/
    uint64_t          m_authCmds;
    uint64_t          m_authErrors;
    CSlabStats		  m_slabStats[MAX_NUMBER_OF_SLAB_CLASSES];
};

struct CDispCmd {
	char		m_cmd;
	bool		m_bListening;
	ETransport	m_transport:8;
	int			m_sfd;
	int			m_eventFlags;
	int			m_readBufferSize;
};
typedef CQueue<CDispCmd, 32>	CDispCmdQue;
typedef CQueue<uint16_t, CNY_MAX_UNIT_CONN_CNT>		CCloseMsgQue;

struct CUdpReqInfo {
	uint16_t		m_connId;
	uint16_t		m_udpReqId;			// udp pkt header req identifier
    struct sockaddr	m_udpReqAddr;		// udp client address
    socklen_t		m_udpReqAddrSize;	// udp client address size
};

struct CXmitMsg;
struct CMsgHdr;

#define XMIT_MSG_IN_USE_LIMIT   12000

struct CRecvBlkSize {
    CRecvBlkSize(bool bBufRestart, int blkSize, int bUdpRestart, int udpBlkSize, int64_t flushTime)
        : m_blkSize(blkSize), m_udpBlkSize(udpBlkSize), 
	  m_bBufRestart(bBufRestart), m_bUdpRestart(bUdpRestart),
	  m_flushTime(flushTime) {}

    int64_t     m_blkSize:32;
    int64_t     m_udpBlkSize:16;
    int64_t     m_bBufRestart:8;
    int64_t     m_bUdpRestart:8;
    int64_t     m_flushTime;
};

struct CWorker {
public:
	void		Setup(int tid, uint8_t *pBlock, size_t blockSize);
	void		InitRespCmdTbl();
	int		FlushRecvBuf(bool bFull=false);
	void		ProcessNewConn(CConn * c);
	bool		RecvPkt(CConn * c);
	int		AddCloseMsgToRecvBuffer();
	void		AddPktToRecvBuffer(uint16_t connId, size_t pktSize);
    bool        IsRecvBufSpaceAvail() {
                    int bufAvail = MCD_RECV_BUF_SIZE - ((m_recvBufWrIdx - m_recvBufRdIdx) & MCD_RECV_BUF_SIZE_MASKQ);
                    int udpAvail = MCD_RECV_UDP_SIZE - ((m_recvUdpWrIdx - m_recvUdpRdIdx) & MCD_RECV_UDP_SIZE_MASKQ);
                    m_bRecvBufSpaceAvail = bufAvail > MCD_RECV_BUF_MAX_BLK_SIZE && udpAvail > MCD_RECV_UDP_MIN_BLK_SIZE
                        && !m_recvBlkSizeQue.IsFull();
                    return m_bRecvBufSpaceAvail;
				}
    int         RecvBufInUse() { return m_recvBlkSizeQue.Size(); }
	int		HandleDispatchCmds();
	void		SendPersUdpNewConns();
	uint32_t	UdpReqAddrHash(void * pUdpReqAddr, int udpReqSize);

    void        LinkConnForXmit(CConn * pConn);
    int        TransmitFromList();

	int		ProcessRespBuf();
    CRspCmdQw * GetHifRspCmd(int qwCnt);
	CConn *		ConnFromFreelist();
	void		ConnAddToFreelist(CConn *c);

	void *		Malloc(size_t size);
	void *		Calloc(int cnt, size_t size);

	CMsgHdr *	AllocMsgHdr();
	void		FreeMsgHdr(CMsgHdr *);

	CXmitMsg *	CallocXmitMsg();
	void		FreeXmitMsg(CXmitMsg *);
    uint32_t GetXmitMsgInUseCnt() { return m_xmitMsgAllocCnt - m_xmitMsgPoolCnt; }

	static void InitCpuSets();
	static void	CreateThread(int tid);
	static void * StartWorkerThread(void *arg);

	void		StartEventLoop();

	static void EventHandler(const int fd, short which, void *arg);

public:
    pthread_t			m_threadId;			/* unique ID of this thread */
    struct event_base *	m_base;				/* libevent handle this thread uses */
	struct event		m_timerEvent;		/* timer event for partial coproc buffer */
    CThreadStats		m_stats;			/* Stats generated by this thread */
	CDispCmdQue			m_dispCmdQue;
	CCloseMsgQue		m_closeMsgQue;
    uint8_t				m_itemLockType;     /* use fine-grained or global item lock */

    CHtAuUnit *         m_pMcdUnit;
    CRspCmdQw           m_rspCmdQw;
	int					m_rspCmdQwCnt;

    // Powersave mode stuff
    uint64_t				m_powersaveTimer;
    uint32_t				m_wakeCount;
    uint64_t				m_noWorkCount;
    short				m_workload;
    bool				m_responsibleFor[16];
    CConn *				m_psPendHead;
    pthread_mutex_t			m_psPendLock;
    bool				m_slowSpin; // Worker #0 only, for now.
    
    int					m_unitId;			// Personality unit identifier

	uint32_t			m_freeMemSize;
	uint8_t *			m_pFreeMem;

	uint32_t			m_msgHdrAllocCnt;
	uint32_t			m_msgHdrPoolCnt;
	CMsgHdr *			m_pMsgHdrPool;

	uint32_t			m_xmitMsgAllocCnt;
	uint32_t			m_xmitMsgPoolCnt;
	CXmitMsg *			m_pXmitMsgPool;

    CConn *             m_pXmitConnFront;
    CConn *             m_pXmitConnBack;
    uint32_t            m_xmitConnCnt;

	int					m_recvBufWrHdrIdx;
	int					m_recvBufWrPktIdx;
	int					m_recvBufWrPktCnt;
    char *              m_pRecvBufBase;
    bool                m_bRecvBufSpaceAvail;

	CUdpReqInfo *		m_pRecvUdpBufBase;

	int64_t				m_recvBufFillTimer;

    CQueue<CRecvBlkSize, MCD_RECV_BUF_MAX_BLK_CNT>    m_recvBlkSizeQue;
    uint32_t            m_recvBufRdIdx;
    uint32_t            m_recvBufWrIdx;
    uint32_t            m_recvUdpRdIdx;
    uint32_t            m_recvUdpWrIdx;
    int                 m_recvUdpWrPktCnt;

#ifdef CHECK_USING_MODEL
    CQueue<int, 128>    m_checkRecvBufLenQue;
	CPersUnit				m_checkUnit;
#endif

	bool				(CConn::*m_pRespCmdTbl[CNY_RESP_CMD_MAX])();

	CConn *				m_connList[CNY_MAX_UNIT_CONN_CNT];

	// connection free list
	CConn *				m_freeConns[CNY_MAX_UNIT_CONN_CNT];
	int					m_freeCurr;
	int					m_connAllocCnt;

#ifndef WIN32
	static uint32_t	m_evenCpuSet;
	static uint32_t	m_oddCpuSet;
    static uint32_t m_coreCnt;
#endif
};

extern CWorker ** g_pWorkers;
